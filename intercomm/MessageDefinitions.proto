// definition of the messages exchanged between uC and CM inside the CCU unit
// these messages are wrapped inside the defined serial protocol
syntax = "proto2";

// specifications of "custom options", which is meta-data describing how the
// information is used in different parts of system
import "google/protobuf/descriptor.proto";

// lists all possible locations where signal/value can be generated or consumed
// full chain is UC -> CM -> DB -> CL 
//   if source is CM and sink is CL, it is implied that it also has to go through DB
//   if source is UC and sink is UC, the signal never leaves UC board
enum FieldEndPoint {
    UC = 1;  // micro-controller board
    CM = 2;  // Computation Module board
    DB = 3;  // Database on CM board
    CL = 4;  // cloud software
}

extend google.protobuf.FieldOptions {
  optional FieldEndPoint source = 50000;
  optional FieldEndPoint sink   = 50001;
}

extend google.protobuf.FileOptions {
  optional uint32 FileVersionMajor = 50010;
  optional uint32 FileVersionMinor = 50011;
}

option (FileVersionMajor) = 0;
option (FileVersionMinor) = 1;

// container message that encapsulates all other messages
message ContainerMessage {
  oneof message {
      StatusUpdate status             = 1;
      CommandRequest commandRequest   = 2;
      CommandResponse commandResponse = 3;
  }
}

message StatusUpdate{
    enum SPIRIERRORS {
        ERR_HV_CELL_UNDER_VOLTAGE = 1;
        ERR_HV_CELL_OVER_VOLTAGE  = 2;
        ERR_OTHER_ERRORS          = 3;
    }

    optional int32 timestamp            = 1    [(source) = UC, (sink) = DB];

    optional float voltageLV            = 2    [(source) = UC, (sink) = CL];
    optional float voltageHV            = 3    [(source) = UC, (sink) = CL];
    // Geo info
    optional float locLongitude         = 4    [(source) = UC, (sink) = CL];
    optional float locLatitude          = 5    [(source) = UC, (sink) = CL];
    optional float locAltitude          = 6    [(source) = UC, (sink) = CL];
    optional float speedGPS             = 7    [(source) = UC, (sink) = CL];
    optional float speedInverter        = 8    [(source) = UC, (sink) = CL];
    optional float speedWheelSensor     = 9    [(source) = UC, (sink) = CL];
    optional float speedDisplayed       = 10   [(source) = UC, (sink) = CL];
    // Inverter
    optional float minInverterCurr      = 11   [(source) = UC, (sink) = DB];
    optional float maxInverterCurr      = 12   [(source) = UC, (sink) = CL];
    optional float avgInverterCurr      = 13   [(source) = UC, (sink) = CL];
    optional float tempInverter         = 14   [(source) = UC, (sink) = CL];
    optional float tempMotor            = 15   [(source) = UC, (sink) = CL];
    // Charger
    optional float minChargerCurrent    = 16   [(source) = UC, (sink) = DB];
    optional float maxChargerCurrent    = 17   [(source) = UC, (sink) = DB];
    optional float avgChargerCurrent    = 18   [(source) = UC, (sink) = CL];
    optional float tempCharger          = 19   [(source) = UC, (sink) = DB];
    // DCDC
    optional float tempDCDC             = 20   [(source) = UC, (sink) = CL];
    optional bool fanDCDCState          = 21   [(source) = UC, (sink) = CL];
    // Lights status
    optional bool frontLong             = 22   [(source) = UC, (sink) = CL];
    optional bool frontShort            = 23   [(source) = UC, (sink) = CL];
    optional bool DRL                   = 24   [(source) = UC, (sink) = CL];
    optional bool frontFog              = 25   [(source) = UC, (sink) = CL];
    optional bool backFog               = 26   [(source) = UC, (sink) = CL];
    optional bool breakLight            = 27   [(source) = UC, (sink) = CL];
    // button statuses                  = 28   [(source) = UC, (sink) = CL];
    optional bool hazardButton          = 29   [(source) = UC, (sink) = CL];
    optional bool panicButton           = 30   [(source) = UC, (sink) = CL];
    // seat related info
    optional bool seatHeaterFR          = 31   [(source) = UC, (sink) = CL];
    optional bool seatHeaterFL          = 32   [(source) = UC, (sink) = CL];
    optional bool seatHeaterRR          = 33   [(source) = UC, (sink) = CL];
    optional bool seatHeaterRL          = 34   [(source) = UC, (sink) = CL];

    optional bool seatSensorFR          = 35   [(source) = UC, (sink) = CL];
    optional bool seatSensorFL          = 36   [(source) = UC, (sink) = CL];
    optional bool seatSensorRR          = 37   [(source) = UC, (sink) = CL];
    optional bool seatSensorRL          = 38   [(source) = UC, (sink) = CL];
    // stalk inputs
    optional bool blinkerLeft           = 39   [(source) = UC, (sink) = CL];
    optional bool blinkerRight          = 40   [(source) = UC, (sink) = CL];
    // door status
    optional bool doorOpenFR            = 41   [(source) = UC, (sink) = CL];
    optional bool doorOpenFL            = 42   [(source) = UC, (sink) = CL];
    optional bool doorOpenRR            = 43   [(source) = UC, (sink) = CL];
    optional bool doorOpenRL            = 44   [(source) = UC, (sink) = CL];

    optional bool doorLockedFR          = 45   [(source) = UC, (sink) = CL];
    optional bool doorLockedFL          = 46   [(source) = UC, (sink) = CL];
    optional bool doorLockedRR          = 47   [(source) = UC, (sink) = CL];
    optional bool doorLockedRL          = 48   [(source) = UC, (sink) = CL];

    repeated SPIRIERRORS activeError    = 49   [(source) = UC, (sink) = CL];
}

enum COMMAND_ORIGIN {
    UC_POWER_MANAGER      = 1;
    CM_VEHICLE_MONITOR    = 2;
    SERVER_FLEET_MANAGER  = 3;
}

message CommandRequest {
    enum TYPE {
        SETDOORLOCK = 1;
    }

    message SetDoorLock {
        optional bool locked = 1;
    }

    optional int32 timestamp               = 1; // at time request is generated
    optional COMMAND_ORIGIN commandOrigin  = 2;
    optional int32 counter                 = 3; // incremented for each command from same origin
    optional TYPE type                     = 4;
    oneof argument {                            // optional command arguments
        SetDoorLock setDoorLock            = 5;
    }
}

message CommandResponse {
    enum RESULT {
        SUCCESS          = 1; // no error, command executed
        UNAUTHORIZED     = 2; // requester failed the authorization process
        UNSUPPORTED      = 3; // command cannot be executed in current hw/sw configuration
        TIMEOUT          = 4; // sub-system failed to respond in time
        BLOCKED          = 5; // conditions don't allow the execution of command
    }

    message SoftwareFileVersion {
        optional uint32 minor = 1;
        optional uint32 major = 2;
    }

    optional int32 timestamp                = 1;  // at time response is generated
    optional COMMAND_ORIGIN commandOrigin   = 2;  // same as request origin
    optional int32 counter                  = 3;  // same request counter
    optional RESULT result                  = 4;
    optional string error_message           = 5;
    oneof retval {                                // optional return values
        SoftwareFileVersion softwareFileVersion     = 6;
    }
}
