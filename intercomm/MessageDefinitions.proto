// definition of the messages exchanged between uC and CM inside the CCU unit
// these messages are wrapped inside the defined serial protocol
syntax = "proto2";

// specifications of "custom options", which is meta-data describing how the
// information is used in different parts of system
import "google/protobuf/descriptor.proto";

// lists all possible locations where signal/value can be generated or consumed
// full chain is UC -> CM -> DB -> CL 
//   if source is CM and sink is CL, it is implied that it also has to go through DB
//   if source is UC and sink is UC, the signal never leaves UC board
enum FieldEndPoint {
    UC = 1;  // micro-controller board
    CM = 2;  // Computation Module board
    DB = 3;  // Database on CM board
    CL = 4;  // cloud software
}

extend google.protobuf.FieldOptions {
  optional FieldEndPoint source = 50000;
  optional FieldEndPoint sink   = 50001;
}

extend google.protobuf.FileOptions {
  optional uint32 FileVersionMajor = 50010;
  optional uint32 FileVersionMinor = 50011;
}

option (FileVersionMajor) = 0;
option (FileVersionMinor) = 1;

// container message that encapsulates all other messages
message ContainerMessage {
  oneof message {
      StatusUpdate status             = 1;
      CommandRequest commandRequest   = 2;
      CommandResponse commandResponse = 3;
  }
}

message StatusUpdate{
    optional int32 timestamp            = 1    [(source) = UC, (sink) = DB];

    // Geo info
    optional float locLongitude         = 4    [(source) = UC, (sink) = CL];
    optional float locLatitude          = 5    [(source) = UC, (sink) = CL];
    optional float locAltitude          = 6    [(source) = UC, (sink) = CL];
    optional float speedGPS             = 7    [(source) = UC, (sink) = CL];
    // Seats
    optional bool seatOccupiedFR          = 35   [(source) = UC, (sink) = CL];
    optional bool seatOccupiedFL          = 36   [(source) = UC, (sink) = CL];
    optional bool seatOccupiedRR          = 37   [(source) = UC, (sink) = CL];
    optional bool seatOccupiedRL          = 38   [(source) = UC, (sink) = CL];

    // stalk inputs
    optional bool blinkerLeft           = 200   [(source) = UC, (sink) = CL];
    optional bool blinkerRight          = 201   [(source) = UC, (sink) = CL];
    // door status
    optional bool doorOpenFR            = 202   [(source) = UC, (sink) = CL];
    optional bool doorOpenFL            = 203   [(source) = UC, (sink) = CL];
    optional bool doorOpenRR            = 204   [(source) = UC, (sink) = CL];
    optional bool doorOpenRL            = 205   [(source) = UC, (sink) = CL];

    optional bool vehicleLocked         = 206   [(source) = UC, (sink) = CL];

    //repeated SPIRIERRORS activeError    = 49   [(source) = UC, (sink) = CL];
}

enum COMMAND_ORIGIN {
    UC_POWER_MANAGER      = 1;
    CM_VEHICLE_MONITOR    = 2;
    SERVER_FLEET_MANAGER  = 3;
}

message CommandRequest {
    enum TYPE {
        SETDOORLOCK         = 1;
        COMFORT             = 2;
        LIGHTS              = 3;
        DRIVETRAIN          = 4;
        AP102CTRL           = 5;
        SETMOTORCALIBRATION = 6;
    }

    message SetDoorLock {
        optional bool locked = 1;
    }

    message Ap102Control {
        optional float speed = 1;
        optional float direction = 2;
    }

    message SetMotorCalibration {
        optional float steerGain      = 1; // multiplication constant 
        optional float steerOffset    = 3;
        optional float speedGain      = 2;
        optional float speedOffset    = 4;
    }

    optional int32 timestamp               = 1; // at time request is generated
    optional COMMAND_ORIGIN commandOrigin  = 2;
    optional int32 counter                 = 3; // incremented for each command from same origin
    optional TYPE type                     = 4;
    oneof argument {                            // optional command arguments
        SetDoorLock setDoorLock                 = 5;
        Ap102Control ap102Control               = 6;
        SetMotorCalibration setMotorCalibration = 7;
    }
}

message CommandResponse {
    enum RESULT {
        SUCCESS          = 1; // no error, command executed
        UNAUTHORIZED     = 2; // requester failed the authorization process
        UNSUPPORTED      = 3; // command cannot be executed in current hw/sw configuration
        TIMEOUT          = 4; // sub-system failed to respond in time
        BLOCKED          = 5; // conditions don't allow the execution of command
    }

    message SoftwareFileVersion {
        optional uint32 minor = 1;
        optional uint32 major = 2;
    }

    optional int32 timestamp                = 1;  // at time response is generated
    optional COMMAND_ORIGIN commandOrigin   = 2;  // same as request origin
    optional int32 counter                  = 3;  // same request counter
    optional RESULT result                  = 4;
    optional string error_message           = 5;
    oneof retval {                                // optional return values
        SoftwareFileVersion softwareFileVersion     = 6;
    }
}
